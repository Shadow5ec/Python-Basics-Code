# Execution Flow 

## Boolean Values 
    This is normally two values True or False. 



- Comparison Operators
     compare two values and evaluate down to a single Boolean value. 
        == Equal to
        != Not equal to
        < Less than
        > Greater than
        <= Less than or equal to
        >= Greater than or equal to

- Boolean Operators 
    The three Boolean operators (and, or, and not) are used to compare Boolean values. 
    True and True True
    True and False False
    False and True False
    False and False False

    
    The not Operator
    Unlike and and or, the not operator operates on only one Boolean value (or expression). 
    This is how it evaluates. 
    not True False
    not False True



- Mixing Boolean and Comparison Operators
        >>> (4 < 5) and (5 < 6)
        True
        >>> (4 < 5) and (9 < 6)
        False
        >>> (1 == 2) or (2 == 2)
        True

    The execution starts with the left side then goes to the right side. 
    (4 < 5) and (5 < 6)
    True and (5 < 6)
    True and True
    True
- Flow Control Statements
    Flow control statements often start with a part called the condition, and all are followed by a block of code called the clause. 
    Conditions 
    condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False. 

    If Statements 

    In plain English, an if statement could be read as, “If this condition is
    true, execute the code in the clause.” In Python, an if statement consists of
    the following:
    •	 The if keyword
    •	 A condition (that is, an expression that evaluates to True or False)
    •	 A colon
    •	 Starting on the next line, an indented block of code (called the if clause)
    Else Statement 
     else statement could be read as, “If this condition is true, execute this code. Or else, execute that code.” 

    Elif Statment 
     The elif statement
    is an “else if” statement that always follows an if or another elif statement.
    It provides another condition that is checked only if any of the previous conditions were False. In code, an elif statement always consists of the following:


    while Loop Statements
    The code in a while clause will be executed as long as the while statement’s condition is True.
    name = ''
    while name != 'your name':
        print("Please type your name")
        name = input()
    print("Thank you")


    break Statements
     If the execution reaches a break statement, it immediately exits the while loop’s clause. In code, a break statement simply contains the break keyword.

    Continue statments 
    When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop’s condition. 

    for Loops and the range() Function
    In code, a for statement looks something like for i in range(5): and always includes the following:
        •	 The for keyword
        •	 A variable name
        •	 The in keyword
        •	 A call to the range() method with up to three integers passed to it
        •	 A colon
        •	 Starting on the next line, an indented block of code (called the for clause)


    Ending a Program Early with sys.exit()
    . However, you can cause the program to terminate, or exit, by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.

# Functions
there are inbuilt functions and functions we creat. 
Purpose of functions is to group code that gets executed multiple times

Statments and parenthesis 

A parameter is a variable that an argument is stored in when a
function is called.
Sample 

def hello(name):
    print("Hello " + name)

hello('john')


#return values and statements 
 In general, the value that a function call evaluates to is called the return value of the function.
 A return statement consists of the following:
    •	 The return keyword
    •	 The value or expression that the function should return

Sample code to understand return statements. 

import random

def getAnswer(answerNumber):
    if answerNumber == 1:
        return "This will return 1"
    elif answerNumber == 2: 
        return "This will return 2"
    else:
        return "Done"
    
r = random.randint(1,9)
num = getAnswer(r)

print(num)

Since return can be passed as an argument to another function you can shorten the above to be. 

import random

def getAnswer(answerNumber):
    if answerNumber == 1:
        return "This will return 1"
    elif answerNumber == 2: 
        return "This will return 2"
    else:
        return "Done"

print(getAnswer(random.randint(1,2)))

# The None Value 

This represents the absence of a value. 
None is the only value of the NoneType data type. (Other programminglanguages might call this value null, nil, or undefined.)

Keyword Arguments and print()

keyword arguments are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters. For example, the print() function has the optional parameters end and sep to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.
Most arguments are identified by their position in the function call. For example, random.randint(1, 10) is different from random.randint(10, 1). 

print('Hello', end='')
print('World')
the output would look like this:
HelloWorld


But you could replace the default separating string by passing the sep keyword argument. 
>>> print('cats', 'dogs', 'mice', sep=',')
cats,dogs,mice


Local and Global Scope
Parameters and variables that are assigned in a called function are said to exist in that function’s local scope. Variables that are assigned outside all functions are said to exist in the global scope.
A variable must be one or the other; it cannot be both local and global.
A local scope is created whenever a function is called.

A local scope is created whenever a function is called. Any variables assigned in this function exist within the local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The
next time you call this function, the local variables will not remember the values stored in them from the last time the function was called.



Try and expect statments, when you are not sure about the error to be thrown you can run this 

try:
    risky_operation()
except Exception as e:
    print("Something went wrong:", e)


Key Concepts Taught 
  - Keyword Arguments and print
  - The None Value
  - Return Values and return Statements
  - def Statements with Parameters
  - Local and Global Scope
  - The global Statement
  - Exception Handling


# Lists 
# Dictionaries and Structuring Data
# Manipulating Strings
